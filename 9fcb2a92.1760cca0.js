(window.webpackJsonp=window.webpackJsonp||[]).push([[52],{196:function(e,t,r){"use strict";r.r(t),r.d(t,"frontMatter",(function(){return o})),r.d(t,"metadata",(function(){return d})),r.d(t,"rightToc",(function(){return c})),r.d(t,"default",(function(){return l}));var n=r(2),s=r(9),a=(r(0),r(225)),o={},d={id:"go-conflux-sdk/doc/conflux_checksum_address_en",title:"conflux_checksum_address_en",description:"Conflux base32Check addresses",source:"@site/docs/go-conflux-sdk/doc/conflux_checksum_address_en.md",permalink:"/docs/go-conflux-sdk/doc/conflux_checksum_address_en",editUrl:"https://github.com/Conflux-Chain/conflux-developer-site/edit/master/docs/go-conflux-sdk/doc/conflux_checksum_address_en.md",lastUpdatedAt:1619172556},c=[{value:"Before CIP37",id:"before-cip37",children:[]},{value:"CIP37 Address",id:"cip37-address",children:[]},{value:"Conflux fullnode RPC",id:"conflux-fullnode-rpc",children:[]},{value:"go-conflux-sdk",id:"go-conflux-sdk",children:[]}],i={rightToc:c};function l(e){var t=e.components,r=Object(s.a)(e,["components"]);return Object(a.b)("wrapper",Object(n.a)({},i,r,{components:t,mdxType:"MDXLayout"}),Object(a.b)("h1",{id:"conflux-base32check-addresses"},"Conflux base32Check addresses"),Object(a.b)("p",null,"As a new public chain, Conflux realizes high performance as well as compatibility with Ethereum. Conflux adopts address format compatible with Ethereum addresses, and thus is compatible with Ethereum Virtual Machine (EVM).\nThe advantage of the compatibility between Conflux and Ethereum is obvious:  it reduces the cost and difficulty of cross-chain migration. But there are also some problems. Since the addresses on Conflux and Ethereum are similar, users may loss their assets when performing cross-chain transactions using ShuttleFlow if they transfer to a mistake address, which is a serious problem. To improve user experience and reduce address mistakes when users use cross-chain functions, Conflux introduces a new address format: base32Check in ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/Conflux-Chain/CIPs/blob/master/CIPs/cip-37.md"}),"CIP37"),"."),Object(a.b)("h3",{id:"before-cip37"},"Before CIP37"),Object(a.b)("p",null,"At first, Conflux adopts the address format similar with Ethereum, which is a hex40 address (hex code with a length of 40 bits). The difference is that Conflux differentiate the addresses with different starts: 0x1 for ordinary individual addresses, 0x8 for smart contracts and 0x0 for in-built contracts."),Object(a.b)("p",null,"Only hex40 addresses with these three starts are available on Conflux. Some Ethereum addresses (with a 0x1 start) can be used as Conflux addresses, while a Conflux address has a 1/16 chance of being used as an Ethereum address."),Object(a.b)("p",null,"Currently, there are three kinds of addresses:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Ordinary addresses: ",Object(a.b)("inlineCode",{parentName:"li"},"0x1"),"386b4185a223ef49592233b69291bbe5a80c527"),Object(a.b)("li",{parentName:"ul"},"Smart contract addresses: ",Object(a.b)("inlineCode",{parentName:"li"},"0x8"),"269f0add11b4915d78791470d091d25cff73ee5"),Object(a.b)("li",{parentName:"ul"},"In-built contract addresses: ",Object(a.b)("inlineCode",{parentName:"li"},"0x0"),"888000000000000000000000000000000000002")),Object(a.b)("p",null,"Because the addresses are not completely compatible on Conflux and Ethereum, users will loss assets when they use a wrong address. Ethereum has introduced a regulation with a checksum in ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md"}),"EIP55")," to change the characters meeting the requirement into the upper case in order to prevent transferring to wrong addresses. Conflux also introduces regulations to change checksums."),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Non-chechsum address: 0x1386",Object(a.b)("inlineCode",{parentName:"li"},"b"),"4185",Object(a.b)("inlineCode",{parentName:"li"},"a"),"223",Object(a.b)("inlineCode",{parentName:"li"},"ef"),"49592233b69291bbe5a80",Object(a.b)("inlineCode",{parentName:"li"},"c"),"527"),Object(a.b)("li",{parentName:"ul"},"Chechsum address: 0x1386",Object(a.b)("inlineCode",{parentName:"li"},"B"),"4185",Object(a.b)("inlineCode",{parentName:"li"},"A"),"223",Object(a.b)("inlineCode",{parentName:"li"},"EF"),"49592233b69291bbe5a80",Object(a.b)("inlineCode",{parentName:"li"},"C"),"527")),Object(a.b)("h3",{id:"cip37-address"},"CIP37 Address"),Object(a.b)("p",null,"In order to solve the problems of mistakenly using wrong addresses, we introduces a brand new base32 checksum address format in ",Object(a.b)("a",Object(n.a)({parentName:"p"},{href:"https://github.com/Conflux-Chain/CIPs/blob/master/CIPs/cip-37.md"}),"CIP37"),". Besides checksum, the new addresses also include information such as network, type."),Object(a.b)("p",null,"Old address vs new address:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"hex40 address: ",Object(a.b)("inlineCode",{parentName:"li"},"0x1"),"386b4185a223ef49592233b69291bbe5a80c527"),Object(a.b)("li",{parentName:"ul"},"base32 address: cfx:aak2rra2njvd77ezwjvx04kkds9fzagfe6ku8scz91")),Object(a.b)("p",null,"The new addresses use customized base32 code address. Currently applied characters are: ",Object(a.b)("inlineCode",{parentName:"p"},"abcdefghjkmnprstuvwxyz0123456789")," (i, l, o, q removed)."),Object(a.b)("p",null,"In new format addresses, network types are included. Up to now there are three types: cfx\uff0ccfxtest\uff0cnet","[n]"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"cfx:aak2rra2njvd77ezwjvx04kkds9fzagfe6ku8scz91"),Object(a.b)("li",{parentName:"ul"},"cfxtest:aak2rra2njvd77ezwjvx04kkds9fzagfe6d5r8e957"),Object(a.b)("li",{parentName:"ul"},"net1921:aak2rra2njvd77ezwjvx04kkds9fzagfe65k87kwdf")),Object(a.b)("p",null,"Meanwhile, new addresses also include address type information, currently four types (types are usually in upper case):"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"user: CFX:TYPE.USER:AAK2RRA2NJVD77EZWJVX04KKDS9FZAGFE6KU8SCZ91"),Object(a.b)("li",{parentName:"ul"},"contract: CFX:TYPE.CONTRACT:ACB2RRA2NJVD77EZWJVX04KKDS9FZAGFE640XW9UAE"),Object(a.b)("li",{parentName:"ul"},"builtin: CFX:TYPE.BUILTIN:AAEJUAAAAAAAAAAAAAAAAAAAAAAAAAAAAJRWUC9JNB"),Object(a.b)("li",{parentName:"ul"},"null: CFX:TYPE.NULL:AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA0SFBNJM2")),Object(a.b)("p",null,"The two address formats (hex40 and base32) are convertible to each other. They are the same if converted to byte arrays. However, when converting hex40 addresses (starting with 0x) into base32check addresses, the network ID information is also required."),Object(a.b)("h3",{id:"conflux-fullnode-rpc"},"Conflux fullnode RPC"),Object(a.b)("p",null,"From v1.1.1, Conflux-rust will apply the new address format. If returns include address information, it will be in the new format."),Object(a.b)("p",null,"If you use hex40 addresses to call RPC, it will return with an error:"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'{\n    "code": -32602,\n    "message": "Invalid params: Invalid base32 address: zero or multiple prefixes."\n}\n')),Object(a.b)("p",null,"If you use a wrong network type (eg. use a testnet address for the mainnet PRC), it will return with an error:"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-js"}),'{\n    "code": -32602,\n    "message": "Invalid parameters: address",\n    "data": "\\"network prefix unexpected: ours cfx, got cfxtest\\""\n}\n')),Object(a.b)("h3",{id:"go-conflux-sdk"},"go-conflux-sdk"),Object(a.b)("h4",{id:"address"},"Address"),Object(a.b)("h5",{id:"create-an-address"},"Create an Address"),Object(a.b)("p",null,"There are four ways to create an address instance. In each way a MustXxx method is provided to realize quick creation. If error occurs when using this method, panic will take place. You can also check whether an address is valid through the returns of the following methods:"),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create via base32 string")),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-go"}),"func NewFromBase32(base32Str string) (cfxAddress Address, err error)\nfunc MustNewFromBase32(base32Str string) (address Address)\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create via hex40 string")),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-go"}),"func NewFromHex(hexAddressStr string, networkID ...uint32) (val Address, err error)\nfunc MustNewFromHex(hexAddressStr string, networkID ...uint32) (val Address)\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create via common.Address")),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-go"}),"func NewFromCommon(commonAddress common.Address, networkID ...uint32) (val Address, err error)\nfunc MustNewFromCommon(commonAddress common.Address, networkID ...uint32) (address Address)\n")),Object(a.b)("ul",null,Object(a.b)("li",{parentName:"ul"},"Create via byte array")),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-go"}),"func NewFromBytes(hexAddress []byte, networkID ...uint32) (val Address, err error)\nfunc MustNewFromBytes(hexAddress []byte, networkID ...uint32) (address Address)\n")),Object(a.b)("p",null,Object(a.b)("inlineCode",{parentName:"p"},"Note:")," The networkId configuration is optional. If it is not set manually, it will be set automatically when sending RPC request in client."),Object(a.b)("h5",{id:"address-instance-method"},"Address instance method"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{className:"language-go"}),"// ToHex returns hex address string and networkID\nfunc (a *Address) ToHex() (hexAddressStr string, networkID uint32)\n\n// ToCommon returns common.Address and networkID\nfunc (a *Address) ToCommon() (address common.Address, networkID uint32, err error) \n\n// MustGetBase32Address returns base32 string of address which doesn't include address type\nfunc (a *Address) MustGetBase32Address() string\n\n// MustGetVerboseBase32Address returns base32 string of address with address type\nfunc (a *Address) MustGetVerboseBase32Address() string\n\n// MustGetHexAddress returns hex format address and panic if error\nfunc (a *Address) GetHexAddress() string\n\n// MustGetCommonAddress returns common address and panic if error\nfunc (a *Address) MustGetCommonAddress() common.Address\n\n// MustGetNetworkID returns networkID and panic if error\nfunc (a *Address) GetNetworkID() uint32\n\n// GetNetworkType returns network type\nfunc (a *Address) GetNetworkType() NetworkType \n\n// GetAddressType returuns address type\nfunc (a *Address) GetAddressType() AddressType \n\n// GetBody returns body\nfunc (a *Address) GetBody() Body\n\n// GetChecksum returns checksum\nfunc (a *Address) GetChecksum() Checksum\n\n// CompleteByClient will set networkID by client.GetNetworkID() if a.networkID not be 0\nfunc (a *Address) CompleteByClient(client NetworkIDGetter) error\n\n// CompleteByNetworkID will set networkID if current networkID isn't 0\nfunc (a *Address) CompleteByNetworkID(networkID uint32) error\n\n// IsValid return true if address is valid\nfunc (a *Address) IsValid() bool\n\n// MarshalText implements the encoding.TextMarshaler interface.\nfunc (a Address) MarshalText() ([]byte, error)\n\n// UnmarshalJSON implements the json.Unmarshaler interface.\nfunc (a *Address) UnmarshalJSON(data []byte) error\n")),Object(a.b)("h4",{id:"networkid"},"NetworkID"),Object(a.b)("p",null,"In the Client class, new method ",Object(a.b)("inlineCode",{parentName:"p"},"GetNetworkID"),"is added to get NetowrkID"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),"func (client *Client) GetNetworkID() (uint32, error)\n")),Object(a.b)("h4",{id:"accountmanager"},"AccountManager"),Object(a.b)("p",null,"AccountManager instantiation requires to send networkId"),Object(a.b)("pre",null,Object(a.b)("code",Object(n.a)({parentName:"pre"},{}),"func NewAccountManager(keydir string, networkID uint32) *AccountManager\n")),Object(a.b)("h4",{id:"contract"},"Contract"),Object(a.b)("p",null,"Solidity is still using hex40 addresses, so when contract objects are interacting with contracts, common.Address is still sueful."),Object(a.b)("h5",{id:"event-decode"},"Event Decode"),Object(a.b)("p",null,"Event decoding will continue to use common.Address"),Object(a.b)("h5",{id:"internal-contract"},"Internal contract"),Object(a.b)("p",null,"The address-related parameters in AdminControl, Sponsor and Staking of in-built contracts will be in base32check format. SDK will help to convert the format."))}l.isMDXComponent=!0},225:function(e,t,r){"use strict";r.d(t,"a",(function(){return u})),r.d(t,"b",(function(){return p}));var n=r(0),s=r.n(n);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function d(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function c(e,t){if(null==e)return{};var r,n,s=function(e,t){if(null==e)return{};var r,n,s={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(s[r]=e[r]);return s}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(s[r]=e[r])}return s}var i=s.a.createContext({}),l=function(e){var t=s.a.useContext(i),r=t;return e&&(r="function"==typeof e?e(t):d(d({},t),e)),r},u=function(e){var t=l(e.components);return s.a.createElement(i.Provider,{value:t},e.children)},b={inlineCode:"code",wrapper:function(e){var t=e.children;return s.a.createElement(s.a.Fragment,{},t)}},m=s.a.forwardRef((function(e,t){var r=e.components,n=e.mdxType,a=e.originalType,o=e.parentName,i=c(e,["components","mdxType","originalType","parentName"]),u=l(r),m=n,p=u["".concat(o,".").concat(m)]||u[m]||b[m]||a;return r?s.a.createElement(p,d(d({ref:t},i),{},{components:r})):s.a.createElement(p,d({ref:t},i))}));function p(e,t){var r=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var a=r.length,o=new Array(a);o[0]=m;var d={};for(var c in t)hasOwnProperty.call(t,c)&&(d[c]=t[c]);d.originalType=e,d.mdxType="string"==typeof e?e:n,o[1]=d;for(var i=2;i<a;i++)o[i]=r[i];return s.a.createElement.apply(null,o)}return s.a.createElement.apply(null,r)}m.displayName="MDXCreateElement"}}]);